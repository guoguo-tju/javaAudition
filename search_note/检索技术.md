# 检索技术20讲



### 1.导读

#### 1.1检索知识全景图

![01检索知识全景图](.\01检索知识全景图.jpg)



## 基础技术篇

### 1.线性结构检索:数组和链表

#### 1.1 如何灵活改造链表提升检索效率

本质上，我们学习链表，就是在学习“非连续存储空间”的组织方案。我们知道，对于“非连续空间”，可以用指针将它串联成一个整体。只要掌握了这个思想，我们就可以在不同的应用场景中，设计出适用的数据结构，而不需要拘泥于链表自身的结构限制。

我们可以来看一个简单的改造例子。比如说，如果我们觉得链表一个节点一个节点遍历太慢，那么我们是不是可以对它做一个简单的改造呢？在掌握了链表的核心思想后，我们很容易就能想到一个改进方案，那就是让链表每个节点不再只是存储一个元素，而是存储一个小的数组。这样我们就能大幅减少节点的数量，从而减少依次遍历节点带来的“低寻址效率”。

比如说，我的链表就只有两个节点，每个节点都存储了一个小的有序数组。这样在检索的时候，我可以用二分查找的思想，先查询第一个节点存储的小数组的末尾元素，看看是否是我们要查询的数字。如果不是，我们要么在第一个节点存储的小数组里，继续二分查找；要么在第二个节点存储的小数组里，继续二分查找。这样的结构就能同时兼顾数组和链表的特点了，而且时间代价也是 O(log n)。

可见，尽管常规的链表只能遍历检索，但是只要我们掌握了“非连续存储空间可以灵活调整”的特性，就可以设计更高效的数据结构和检索算法了。



### 2.非线性结构检索

对于数据频繁变化的应用场景，有序数组并不是最适合的解决方案。我们一般要考虑采用非连续存储的数据结构来灵活调整。同时，为了提高检索效率，我们还要采取合理的组织方式，让这些非连续存储的数据结构能够使用二分查找算法。

数据组织的方式有两种，一种是二叉检索树 , 一种是跳表.

#### 2.1二叉检索树

我们能在有序链表中以 O(1) 的时间代价快速访问到中间节点，是不是就可以和有序数组一样使用二分查找 , 通过这个思路我们将有序链表改造成二叉检索树. 它的左子树的所有节点的值都小于根节点，同时右子树所有节点的值都大于等于根节点.

一个平衡的二叉检索树使用二分查找的检索效率是 O(log n)，但如果我们不做额外的平衡控制的话，二叉检索树的检索性能最差会退化到 O(n)，也就和单链表一样了。所以，AVL 树(平衡二叉树)和红黑树这样平衡性更强的二叉检索树，在实际工作中应用更多 , 我们常见的 C++ 中的 Set 和 Map 等数据结构，底层就是用红黑树实现的。

#### 2.2跳表

我们可以为有序链表的某些节点增加更多的指针。这些指针都指向不同距离的后续节点。这样一来，链表就具备了更高效的检索能力。这样的数据结构就是跳表（Skip List).

一个理想的跳表，就是从链表头开始，用多个不同的步长，每隔2^n 个节点做一次直接链接（n 取值为 0，1，2……）。跳表中的每个节点都拥有多个不同步长的指针，我们可以在每个节点里，用一个数组 next 来记录这些指针。next 数组的大小就是这个节点的层数，next[0]就是第 0 层的步长为 1 的指针，next[1]就是第 1 层的步长为 2 的指针，next[2]就是第 2 层的步长为 4 的指针，依此类推。你会发现，不同步长的指针，在链表中的分布是非常均匀的，这使得整个链表具有非常平衡的检索结构。

举个例子，当我们要检索 k=a6时，从第一个节点a1开始，用最大步长的指针开始遍历，直接就可以访问到中间节点 a5。但是，如果沿着这个最大步长指针继续访问下去，下一个节点是大于 k 的 a9，这说明 k 在 a5和 a9之间。那么，我们就在 a5和 a9之间，用小一个级别的步长继续查询。这时候，a5的下一个元素是 a7，a7依然大于 k 的值，因此，我们会继续在 a5和 a7之间，用再小一个级别的步长查找，这样就找到 
a6了。这个过程其实就是二分查找。时间代价是 O(log n)。

![02理想的跳表](.\02理想的跳表.jpg)

##### 2.2.1跳表的检索空间平衡方案

当我们要在跳表中插入元素时，节点之间的间隔距离就被改变了。如果要保证理想链表的每隔 2^n 个节点做一次链接的特性，我们就需要重新修改许多节点的后续指针，这会带来很大的开销。所以，在实际情况下，我们会在检索性能和修改指针代价之间做一个权衡。为了保证检索性能，我们不需要保证跳表是一个“理想”的平衡状态，只需要保证它在大概率上是平衡的就可以了。因此，当新节点插入时，我们不去修改已有的全部指针，而是仅针对新加入的节点为它建立相应的各级别的跳表指针。

首先，我们需要确认新加入的节点需要具有几层的指针。我们通过随机函数来生成层数，比如说，我们可以写一个函数RandomLevel()，以 (1/2)^n 的概率决定是否生成第 n 层。这样，通过简单的随机生成指针层数的方式，我们就可以保证指针的分布，在大概率上是平衡的。在确认了新节点的层数 n 以后，接下来，确认k的插入位置 , 同上面查询的思路一致.然后, 我们需要将新节点和前后的节点连接起来，也就是为每一层的指针建立前后连接关系。其实每一层的指针链接，你都可以看作是一个独立的单链表的修改，因此我们只需要用单链表插入节点的方式完成指针连接即可。

![03跳表插入新的元素](.\03跳表插入新的元素.jpg)

通过这样一种方式，我们可以大大减少修改指针的代价。当然，由于新加入节点的层数是随机生成的，因此在节点数目较少的情况下，如果指针分布的不合理，检索性能依然可能不高。但是当节点数较多的时候，指针会趋向均匀分布，查找空间会比较平衡，检索性能会趋向于理想跳表的检索效率，接近O(log n) .

相比于复杂的平衡二叉检索树，如红黑树，跳表用一种更简单的方式实现了检索空间的平衡。并且，由于跳表保持了链表顺序遍历的能力，在需要遍历功能的场景中，跳表会比红黑树用起来更方便。在Redis 这样的系统中，我们经常会利用跳表来代替红黑树作为底层的数据结构。





问答收集

1.-如何搭建公司的搜索引擎系统，希望做到业务数据不受到搜索引擎服务的影响，同时搜索引擎能比较实时提供查询统计功能。

-这个具体要看你们的“实时查询统计”的需求到底是怎么样的。如果是简单的一些固定统计，那么elastic search就可以提供；但如果是偏OLAP的灵活分析查询需求，那其实Druid和clickhouse是更合适的选择。ps:Druid和clickhouse都是基于lsm树实现的。lsm树在进阶实战篇和系统案例篇中我都会介绍。

2.-向量检索目前工业界的采用的方案是根据数据量来的吗？另外分布式向量检索这个在工业界是否是个尚未开垦的荒地？

-不算尚未开垦，不过也不算成熟。许多团队都在摸索。我们是自研的；而在业界主要是两大类方向:一种是将faiss改造为支持分布式；另一种是在es上做插件扩展。

3.-对于单个查询值 k，我们已经熟悉了如何使用二分查找。那给出两个查询值 x 和 y 作为查询范围，如果要在有序数组中查找出大于 x 和小于 y 之间的所有元素，我们应该怎么做呢？

-可以先二分从min和max之间找出x,然后再二分从x和max之间找出y，中间的元素就是区间内的

4.-二叉检索树和跳表都能做到 O(log n) 的查询时间代价，还拥有灵活的调整能力，并且调整代价也是 O(log n)（包括了寻找插入位置的时间代价）。而有序数组的查询时间代价也是 O(log n)，调整代价是 O(n)，那这是不是意味着二叉检索树或者跳表可以用来替代有序数组呢？有序数组自己的优势又是什么呢？

-1.有序数据占用的内存空间小于调表 2.有序数组的读取操作能保持在很稳定的时间复杂度，而跳表在达到一定数量级之后才能. 3.因为数组存储空间是连续的，可以利用CPU的局部性原理加快查询.4.范围查找效率更高（CPU缓存 + 内存拷贝）

